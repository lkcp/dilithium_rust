use crate::reduce::montgomery_reduce;
use crate::hints::{high_bits, low_bits};

static ZETAS: [i32; 255] = [25847, -2608894, -518909, 237124, -777960, -876248, 466468, 1826347, 2353451, -359251, -2091905, 3119733, -2884855, 3111497, 2680103, 2725464, 1024112, -1079900, 3585928, -549488, -1119584, 2619752, -2108549, -2118186, -3859737, -1399561, -3277672, 1757237, -19422, 4010497, 280005, 2706023, 95776, 3077325, 3530437, -1661693, -3592148, -2537516, 3915439, -3861115, -3043716, 3574422, -2867647, 3539968, -300467, 2348700, -539299, -1699267, -1643818, 3505694, -3821735, 3507263, -2140649, -1600420, 3699596, 811944, 531354, 954230, 3881043, 3900724, -2556880, 2071892, -2797779, -3930395, -1528703, -3677745, -3041255, -1452451, 3475950, 2176455, -1585221, -1257611, 1939314, -4083598, -1000202, -3190144, -3157330, -3632928, 126922, 3412210, -983419, 2147896, 2715295, -2967645, -3693493, -411027, -2477047, -671102, -1228525, -22981, -1308169, -381987, 1349076, 1852771, -1430430, -3343383, 264944, 508951, 3097992, 44288, -1100098, 904516, 3958618, -3724342, -8578, 1653064, -3249728, 2389356, -210977, 759969, -1316856, 189548, -3553272, 3159746, -1851402, -2409325, -177440, 1315589, 1341330, 1285669, -1584928, -812732, -1439742, -3019102, -3881060, -3628969, 3839961, 2091667, 3407706, 2316500, 3817976, -3342478, 2244091, -2446433, -3562462, 266997, 2434439, -1235728, 3513181, -3520352, -3759364, -1197226, -3193378, 900702, 1859098, 909542, 819034, 495491, -1613174, -43260, -522500, -655327, -3122442, 2031748, 3207046, -3556995, -525098, -768622, -3595838, 342297, 286988, -2437823, 4108315, 3437287, -3342277, 1735879, 203044, 2842341, 2691481, -2590150, 1265009, 4055324, 1247620, 2486353, 1595974, -3767016, 1250494, 2635921, -3548272, -2994039, 1869119, 1903435, -1050970, -1333058, 1237275, -3318210, -1430225, -451100, 1312455, 3306115, -1962642, -1279661, 1917081, -2546312, -1374803, 1500165, 777191, 2235880, 3406031, -542412, -2831860, -1671176, -1846953, -2584293, -3724270, 594136, -3776993, -2013608, 2432395, 2454455, -164721, 1957272, 3369112, 185531, -1207385, -3183426, 162844, 1616392, 3014001, 810149, 1652634, -3694233, -1799107, -3038916, 3523897, 3866901, 269760, 2213111, -975884, 1717735, 472078, -426683, 1723600, -1803090, 1910376, -1667432, -1104333, -260646, -3833893, -2939036, -2235985, -420899, -2286327, 183443, -976891, 1612842, -3545687, -554416, 3919660, -48306, -1362209, 3937738, 1400424, -846154, 1976782];

static Q: i32 = 8380417;
const F: i32 = 41978; // mont^2 /256

#[derive(Debug, Copy, Clone)]
pub struct Poly {
    pub coeffs: [i32; 256],
}

impl Poly {
    pub fn new() -> Poly {
        Poly { coeffs: [0; 256] }
    }


    pub fn point_wise_mul(&mut self, b: &Poly) -> Poly {
        let mut i: usize = 0;
        let mut c: Poly = Poly::new();
        loop {
            c.coeffs[i] = montgomery_reduce(self.coeffs[i] as i64 * b.coeffs[i] as i64); // mont(a, b) = abR^{-1}
            i += 1;
            if i == 256 {
                break;
            }
        }
        c
    }

    pub fn add(&self, b: &Poly) -> Poly {
        let mut c: Poly = Poly::new();
        let mut i: usize = 0;
        loop {
            c.coeffs[i] = (self.coeffs[i] + b.coeffs[i]) % Q;
            i += 1;
            if i == 256 {
                break;
            }
        }
        c
    }

    pub fn sub(&self, b: &Poly) -> Poly {
        let mut c: Poly = Poly::new();
        let mut i: usize = 0;
        loop {
            c.coeffs[i] = (self.coeffs[i] - b.coeffs[i]) % Q;
            i += 1;
            if i == 256 {
                break;
            }
        }
        c
    }
}

impl Poly {
    // perform forward ntt
    pub fn ntt(&mut self) -> () {
        let mut k: usize = 0;
        let mut len: usize = 128;
        loop {
            let mut start: usize = 0;
            loop {
                let zeta: i32 = ZETAS[k];
                k += 1;
                let mut i: usize = 0;
                loop {
                    let tiwddle: i32 =
                        montgomery_reduce(zeta as i64 * self.coeffs[start + i + len] as i64); // mont(c * zR) = cz mod Q
                    self.coeffs[start + len + i] = self.coeffs[start+i] - tiwddle;
                    self.coeffs[start + i] = self.coeffs[start+i] + tiwddle;
                    i += 1;
                    if i == len {
                        break;
                    }
                }
                start += len * 2;
                if start == 256 {
                    break;
                }
            }
            len >>= 1;
            if len == 0 {
                break;
            }
        } 
    }

    // perform inverse ntt
    pub fn intt(&mut self) -> () {
        let mut k: usize = 255;
        let mut len: usize = 1;
        loop {
            let mut start: usize = 0;
            loop {
                k -= 1;
                let zeta: i32 = -ZETAS[k];
                
                let mut i: usize = 0;
                loop {
                    let temp: i32 = self.coeffs[start + i];
                    self.coeffs[start + i] = self.coeffs[start + i] + self.coeffs[start + i + len];
                    self.coeffs[start + i + len] =
                        montgomery_reduce((temp - self.coeffs[start + i + len]) as i64 * zeta as i64);
                    i += 1;
                    if i == len {
                        break;
                    }
                }
                start += len * 2;
                if start == 256 {
                    break;
                }
            }
            len <<= 1;
            if len == 256 {
                break;
            }
        }
        for coeff in self.coeffs.iter_mut() {
            *coeff = montgomery_reduce(*coeff as i64 * F as i64)
        } // eliminate the R^{-1} introduced by point-wise multiplication
    }
    // Add Q if negative
    pub fn caddq(&mut self) -> () {
        for coeff in self.coeffs.iter_mut() {
            *coeff += (*coeff >> 31) & Q;
        }
    }

    pub fn high_bits(&self, gamma2: i32) -> Poly {
        let mut t = Poly::new();

        for i in 0..256 {
            t.coeffs[i] = high_bits(self.coeffs[i], gamma2);
        }

        t
    }

    pub fn low_bits(&self, gamma2: i32) -> Poly {
        let mut t = Poly::new();

        for i in 0..256 {
            t.coeffs[i] = low_bits(self.coeffs[i], gamma2);
        }

        t
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn poly_add_test() {
        let a : Poly = Poly { coeffs: [1; 256] };
        let b : Poly = Poly { coeffs: [2; 256] };
        let c = a.add(&b);
        assert_eq!(c.coeffs, [3; 256]);
    }

    #[test]
    fn ntt_base_test() {
        let mut a : Poly = Poly { coeffs: [-123; 256] };
        let mut b : Poly = Poly { coeffs: [-123; 256] };
        a.ntt();
        a.intt();
        for coeff in b.coeffs.iter_mut() {
            *coeff = montgomery_reduce(*coeff as i64 * F as i64 * 256);
        }
        assert_eq!(a.coeffs, b.coeffs);
    }

    #[test]
    fn poly_mul_test() {
        let mut a: Poly = Poly { coeffs: [11; 256] };
        let mut b: Poly = Poly { coeffs: [15; 256] };
        a.ntt();
        b.ntt();
        a = a.point_wise_mul(&b);
        a.intt();

        let c: Poly = Poly { coeffs: [11; 256] };
        let d: Poly = Poly { coeffs: [15; 256] };
        let mut e: Poly = Poly { coeffs: [0; 256] };


        let mut i = 0;
        loop {
            let mut j = 0;
            loop {
                if i+j < 256 {e.coeffs[i+j] += c.coeffs[i]*d.coeffs[j];}
                else {e.coeffs[i+j-256] -= c.coeffs[i]*d.coeffs[j];}        
                j += 1;
                if j == 256 {break;}
            }
            i += 1;
            if i == 256 {break;}
        }
        assert_eq!(a.coeffs, e.coeffs);
    }

    // test for Poly::poly_add_test()
    #[test]
    fn poly_add_test_2() {
        let a : Poly = Poly { coeffs: [1; 256] };
        let b : Poly = Poly { coeffs: [2; 256] };
        let c = a.add(&b);
        assert_eq!(c.coeffs, [3; 256]);
    }

    #[test]
    fn test_ntt_2(){
        let mut coffs = [  1,   0,  -1,  -1,  -1,   1,   0,  -1,   1,   1,  -2,   0,  -1,   2,  -1,   0,   2,   1,  -1,   2,   2,  -2,   0,  -2,   0,   2,  -1,   0,   1,   1,   1,  -2,   0,  -1,   0,   1,   1,   2,  -1,  -2,  -2,   2,  -2,   2,  -1,  -1,  -2,  -2,   0,  -2,   0,  -2,   1,  -1,   2,   1,  -2,  -2,  -2,  -2,   2,  -2,   0,   0,   1,   0,  -2,   2,   1,   0,  -2,  -2,  -2,   0,  -1,   0,  -2,   2,   2,   0,  -2,  -2,   0,  -1,  -2,   2,   1,   1,   1,   0,   0,  -1,  -2,   1,  -1,   2,  -1,   1,  -1,  -1,  -1,   1,   1,   1,   2,   0,   0,   2,   0,   2,  -1,  -2,  -2,  -2,   2,  -2,   2,   0,  -1,  -1,   1,   2,   2,   2,   0,   2,   2,   2,  -2,  -2,  -1,  -1,  -1,  -1,   1,   0,   2,   0,   1,   0,   2,  -1,  -2,   0,   0,   1,   0,  -2,  -1,  -2,   2,   2,   2,  -2,   1,   1,  -2,  -1,  -2,  -1,  -2,   0,   0,  -2,  -2,  -1,   2,   0,  -2,   1,   1,   0,   0,   2,   2,   2,   1,   2,   1,  -2,  -2,  -2,  -1,  -2,  -2,   1,   1,   2,   0,  -1,  -1,   1,   0,  -1,   1,  -2,   0,   1,   2,   1,   2,   0,   1,  -1,  -1,   1,  -2,   2,   2,  -2,  -2,  -2,  -1,  -1,   2,   2,  -2,   1,  -1,   2,   2,  -1,   1,   2,  -2,   0,   0,  -2,   1,   1,   0,  -1,   1,   2,   1,  -1,   2,   0,   1,   1,  -2,   2,  -2,  -2,   2,  -1,   2,   2,  -1,   1,  -2,  -1,  -1,  -1,  -2,  -2];
        let mut a : Poly = Poly { coeffs: coffs };
        a.ntt();
        let mut coff_hat = [210230, 2636012, 3886283, 1125059, -4039898, -11600414, 623878, -2367022, -2974975, -2570671, -4889616, -2203018, 1946372, -963058, -66152, 6828334, -4688986, 1037916, 3312010, 3295112, 4376443, 9861011, 4174230, 10269824, 3403913, 28177, 2766051, 4316343, 2784966, 3021218, -2527676, 3701480, -2995305, -5286161, 7218621, 294601, -9855092, -2094710, -2278441, 4717127, 175960, 3525808, 6436790, 11329618, 1233332, 2962308, 2502583, 8395969, 6926207, 4454081, 11806176, 12330356, 10505621, 7853011, 17916154, 9561322, 7055900, 822474, 4038409, -956831, 6687990, 87730, 3462602, -1650818, -11027843, -13610759, -16641078, -15929568, -15720798, -11605192, -13914347, -21530327, -5309954, -13067272, -7012193, -7376765, -6565257, -3678601, -12777378, -8642108, -7609824, -3739376, -9091243, -2155241, -17085418, -9269084, -7098745, -15157213, 1965231, -1316141, -11164436, -4560678, 2727278, -5411254, 5021888, 2285248, 10577108, 6520202, 2215654, 1625588, -2589099, 1541587, 5189943, 5824545, -6116711, -6910513, -2464650, 1657202, -1627973, -1515745, -6048249, -6307433, -14627738, -11436908, -5947298, -3866488, 507754, -7679798, 1650661, -2850489, -5301662, -1624032, 912132, 6044834, -2445125, -384261, -7370181, -1185337, 7607915, 752101, -5032820, -1668396, 4129390, 5840782, 5122511, 7232677, 8319960, 6729504, 4805156, 5430964, 4698966, 6260232, 1439905, 8255617, 2993752, -1129934, -1978149, -6921649, 1444764, -1256252, 3143111, 5079629, -4801788, 169362, -4936457, 3318963, -9358429, -10021685, -5172214, -3358832, 8405022, 16589612, 7791772, 9155966, 4336379, 3157219, 8834917, 3146193, 12428210, 18177118, 11000407, 12114533, 5104304, 7015976, 7822036, 10367696, 4390407, -1596737, 9402022, 9701872, 8471025, 4930993, 2922658, 4061360, 15900450, 12657556, 5981866, 6956844, 16735308, 13520980, 7765115, 15451305, -11913592, -4785352, -9213397, -9394979, 7194471, -992977, -758816, -7689926, -7276626, -8100570, -7458927, -4960029, -6700301, -260269, -12529767, -9409695, -8991582, -3388942, -7289085, -11541011, -1982632, 1637468, -5477562, -8597302, 5617649, 7133653, 3529990, 9137996, -4453949, 1934709, -3793255, 2108847, 2420381, -3154857, 2952406, 1455846, 764257, 4351711, -3014269, -4397979, 3407820, 8071182, 1126850, 3404488, 3968681, 6544157, 2975333, 10016233, -2580273, -6492455, -3014290, -3377806, -2335256, -775782, -823534, 2177284, -8382948, -11556588, -6035185, -9113943, -9188126, -3567744, -7766110, -11028348];
        assert_eq!(a.coeffs, coff_hat);
    }
    
}